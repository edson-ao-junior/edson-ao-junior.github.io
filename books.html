<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<meta http-equiv="content-type" content="text/html;charset=utf-8" />
<head>

<meta charset="utf-8">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Books</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<link href="favicon.ico" rel="icon">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "index.html",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}
</script>


<link rel="stylesheet" href="styles.scss">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>

<header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="index-2.html">
    <span class="navbar-title"></span>
    </a>
  </div>
            <!-- <div id="quarto-search" class="" title="Search"></div> -->
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>

<div class="collapse navbar-collapse" id="navbarCollapse">
  <ul class="navbar-nav navbar-nav-scroll me-auto">
    <li class="nav-item">
      <a class="nav-link active" href="index.html" aria-current="page"> 
      <span class="menu-text">Home</span></a>
    </li>  
    <li class="nav-item">
      <a class="nav-link" href="research.html"> 
      <span class="menu-text">Research</span></a>
    <li>      
    <li class="nav-item">
      <a class="nav-link" href="publications.html"> 
      <span class="menu-text">Publications</span></a>
    <li>  
      <li class="nav-item">
        <a class="nav-link" href="books.html"> 
        <span class="menu-text">Books</span></a>
    <li>  
    <li class="nav-item">
      <a class="nav-link" href="teaching.html"> 
      <span class="menu-text">Teaching</span></a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="students.html"> 
      <span class="menu-text">Students</span></a>
    </li>
    <li class="nav-item">
      <a class="nav-link" href="service.html"> 
      <span class="menu-text">Service</span></a>
    </li>  
    <li class="nav-item">
      <a class="nav-link" href=""> 
      <span class="menu-text">My Open Science Manifest</span></a>
    </li>  
  </ul>
</div> 

<div class="quarto-navbar-tools">
  <!-- <a href="" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-mastodon"></i></a>     -->
</div>
</div> 
</nav>
</header>

<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<main class="content" id="quarto-document-content">


<!-- conteudo a partir daqui -->

<header id="title-block-header" class="quarto-title-block default">
  <div class="quarto-title">
    <h1 class="title">Books</h1>    
  </div>
</header>

<hr>

<table>
  <tbody>
      <tr>
          <td><img src="images/book_cover_2023.png" width="90%" height="90%"></td>
          <td> <a href="https://doi.org/10.1007/978-3-031-18556-4" target="_blank"><img src="images/doi.png" width="2.5%" height="2.5%"></a>
            OliveiraJr, E. (Editor)
            <b> UML-Based Software Product Line Engineering with SMarty</b>.
            <i>Springer</i>. 
             ISBN/ISSN: 978-3-031-18556-4. 
            2023.
          </td>
      </tr>

      <tr>
        <td colspan="2">          
          <br>
          This book is about software product lines (SPLs) designed and developed taking UML diagrams as the primary basis, modeled according to a rigorous approach composed of an UML profile and a systematic process for variability management activities, forming the Stereotype-based Management of Variability (SMarty) approach. <br><br>
          The book consists of five parts. Part I provides essential concepts on SPL in terms of the first development methodologies. It also introduces variability concepts and discusses SPL architectures finishing with the SMarty approach. Part II is focused on the design, verification and validation of SMarty SPLs, and Part III concentrates on the SPL architecture evolution based on ISO/IEC metrics, the SystEM-PLA method, optimization with the MOA4PLA method, and feature interaction prevention. Next, Part IV presents SMarty as a basis for SPL development, such as, the M-SPLearning SPL for mobile learning applications, the PLeTs SPL for testing tools, the PlugSPL plugin environment for supporting the SPL life cycle, the SyMPLES approach for designing embedded systems with SysML, the SMartySPEM approach for software process lines (SPrL), and re-engineering of class diagrams into an SPL. Eventually, Part V promotes controlled experimentation in UML-based SPLs, presenting essential concepts on how to plan, conduct, and document experiments, as well as showing several experiments carried out with SMarty.<br><br>
          This book aims at lecturers, graduate students and experienced practitioners. Lecturers might use the book for graduate level courses about SPL fundamentals and tools; students will learn about the SPL engineering process, variability management, and mass customization; and practitioners will see how to plan the transition from single-product development to an SPL-based process, how to document inherent variability in a given domain, or how to apply controlled experiments to SPLs.
        
        </td>
      </tr>

    </tbody>
  </table>
  
      <hr>

   <table>
    <tbody>
      <tr>
        <td> <img src="images/java3-2021.png" width="90%" height="90%"></td>
        <td> <img src="images/brasil-icon.jpg" width="3%" height="3%">
          OliveiraJr, E.; Noel, A. A.; Pascutti, M. C. D.; Florindo, R. A.; Freitas. J. A.; Pedroso, V. M.
          <b> Programação III - Java</b>.
          <i>UniCesumar</i>. 
          ISBN/ISSN: 9788580846072. 
          2021.
        </td>
    </tr>

    <tr>
      <td colspan="2">          
        <br>
        Este livro está organizado em cinco unidades e todas estão, estreitamente, relacionadas. Na Unidade 1, apresentaremos alguns conceitos referentes à disciplina. Você notará, durante a leitura das outras unidades, que esses conceitos são utilizados com frequência. A engenharia de software surgiu mediante a necessidade de tornar o desenvolvimento de software confiável, com etapas bem definidas, custo e cronograma previsíveis, fatos que não aconteciam até 1968, quando o termo engenharia de software foi proposto. Além disso, gostaríamos de ressaltar que o software compreende, além dos programas, toda a documentação referente a ele, e a engenharia de software é a disciplina que trata dessa documentação.<br><br>

        Na Unidade 2, daremos início à aplicação dos conhecimentos da engenharia de software na linguagem de programação Java. Abordaremos, primeiramente, os conceitos relacionados a modificadores de acesso e a encapsulamento. Esses recursos formam um dos pilares da programação orientada a objetos, recurso este que garante a integridade e o controle de acesso aos atributos e métodos.<br><br>
        
        Continuando a aplicação dos conceitos de engenharia de software, na Unidade 3, abarcaremos mais dois pilares da programação orientada a objetos: a herança e o polimorfismo. Ambos estão relacionados, uma vez que, a partir do recurso da herança, ou seja, quando o filho herda características do pai, é possível especializar alguma operação. Nesse caso, temos que o filho pode implementar uma ação que o pai desenvolve, contudo ela pode ser diferente ou igual.<br><br>
        
        Na Unidade 4, abordaremos algumas regras de desenvolvimento. A primeira será as classes abstratas, que funcionarão como modelo de desenvolvimento para outras classes que estão recebendo herança dela, ou seja, a classe que herda de uma classe abstrata deve implementar os métodos que estão marcados para serem implementados nas classes filhas. Outra regra é a interface, esta rege um contrato entre analista e desenvolvedor; aqui, quando construímos uma interface e uma classe a implementa, ela é obrigada a implementar todos os métodos, funcionando, assim, como um contrato. <br><br>
        
        Finalmente, chegamos à última unidade do nosso material. Esta unidade é o fechamento das etapas do processo de software, onde realizaremos a implementação de um estudo de caso por meio da realização da nova análise desse estudo, agora, na visão do desenvolvedor. Assim, chegamos ao final do nosso livro. Esperamos, sinceramente, que a sua leitura seja agradável e que este conteúdo possa contribuir para o seu crescimento pessoal, acadêmico e profissional.
        

      </td>
    </tr>

  </tbody>
</table>
      
<hr>


<table>
  <tbody>
    <tr>
      <td> <img src="images/java2-2018.png" width="90%" height="90%"></td>
      <td> <img src="images/brasil-icon.jpg" width="3%" height="3%">
        OliveiraJr, E.; Noel, A. A.
        <b> Programação II - Java</b>.
        <i>UniCesumar</i>. 
        ISBN/ISSN: 9788545911906. 
        2018.
      </td>
  </tr>

  <tr>
    <td colspan="2"> 
      <br>         
      Inicialmente, como você já deve ter lido e exercitado todos os conceitos básicos de Java no livro Programação em Java I, este livro abordará conceitos mais avançados de orientação a objetos como sobrecarga em Java, que é diferente da sobreposição que estudamos no livro I. A sobreposição permite redeir o comportamento (implementação) de um método que foi herdado, possibilitando que a subclasse possua os dois comportamentos: o herdado e o implementado. Já a sobrecarga permite que você use um mesmo identiicador (nome) para métodos e construtores de uma mesma classe, mudando somente a assinatura destes, além de tratamento de exceções.<br><br>

      A Unidade II abordará classes abstratas e interfaces. As classes abstratas podem possuir métodos concretos (com implementação) e métodos abstratos (somente a assinatura) sem fornecer uma implementação padrão. As subclasses concretas de uma classe concreta devem implementar os métodos concretos. Esta é uma forma de garantir que o método será implementado de acordo com a classe a qual se destina. Já interfaces possuem somente métodos abstratos, porém não fornecem suporte à característica de herança.<br><br>
      
      Na Unidade III, você entenderá os elementos essenciais para se trabalhar com vários objetos de uma mesma classe ao mesmo tempo: arrays e coleções Java. Existem vários tipos de coleções, cada uma com um propósito e um conjunto de características próprias que são usadas em diversas situações diferentes.<br><br>
      
      A Unidade IV abordará a criação de interfaces gráicas desktop por meio das API AWT e Swing. Interfaces gráicas em Java envolvem o projeto e a construção de layouts para que os elementos gráicos de interação (botões, caixas, campos etc.) possam ser acomodados. Interfaces gráicas não podem dispensar o tratamento de exceções, caracterizadas por interrupções abruptas da execução de código Java, sem que o usuário possa ter a chance de interagir com o programa. Para tanto, isolamos esses códigos permitindo que o programa Java não seja simplemente abortado sem uma justiicativa.      
    </td>
  </tr>

</tbody>
</table>

<hr>

<table>
  <tbody>
    <tr>
      <td> <img src="images/java1-2018.png" width="90%" height="90%"></td>
      <td> <img src="images/brasil-icon.jpg" width="3%" height="3%">
        OliveiraJr, E.; Noel, A. A.
          <b> Programação I - Java</b>.
          <i>UniCesumar</i>. 
          ISBN/ISSN: 9788545911890. 
          2018.
      </td>
  </tr>

  <tr>
    <td colspan="2">          
      <br>
      Inicialmente, o livro abordará conceitos básicos da linguagem Java, desde a sua criação até o processo de compilação e execução e, em seguida, serão apresentados os demais conceitos para que você possa ter uma noção de programação orientada a objetos com a linguagem Java. Escrever este material foi um desafio, pois é necessário expressar os conceitos de uma forma clara para que você, caro(a) aluno(a), possa entender a lógica dos exemplos. Assim, espero que você goste do que foi colocado aqui.<br><br>

      Na Unidade I, teremos a apresentação da história e evolução da linguagem Java, desde as suas primeiras versões, em que só existia a linguagem Java puramente e algumas poucas bibliotecas disponíveis. Além disso, será apresentada a tecnologia Java onde a linguagem Java está inserida atualmente e as principais bibliotecas disponíveis para cada plataforma Java de desenvolvimento. O processo de compilação e interpretação de programas Java é apresentado, destacando cada fase e os elementos necessários para que um programa Java possa ser executado.<br><br>
      
      A Unidade II abordará as estruturas básicas de um programa em Java, como: tipos primitivos, declaração e inicialização de variáveis e escopo de variáveis. Estruturas de controle, repetição e seleção serão apresentadas para permitir que programas Java possam ser executados de forma a terem fluxos de informações diferentes em momentos diferentes de sua execução. Para tanto, estruturas como if, do-while e switch podem ser usadas. Na Unidade III você entenderá a diferença entre classes e objetos Java. Você verá que uma classe Java serve como um modelo para que os objetos (instâncias) daquela classe possam ser criados e permitir que o programa Java tenha “vida”. Mas para entender esses conceitos, serão apresentados os principais elementos que compõem uma classe Java: atributos, métodos, construtores, e o método main. <br><br>
      
      A Unidade IV abordará um dos conceitos mais importantes em programação orientada a objetos, o encapsulamento. Este conceito serve para proteger os dados de uma classe de acessos indevidos por elementos de outras classes ou até mesmo de outros pacotes. Porém, para entender tal conceito, é necessário aprender os chamados modificadores de acesso da linguagem Java: private, public, protected e default.<br><br>
      
      Por fim, na Unidade V serão apresentados outros dois conceitos fundamentais em programação orientada a objetos: herança e polimorfismo. Herança permite criar uma hierarquia de classes que possuem um conjunto de atributos e métodos comuns, mas com seus tipos próprios. Já polimorfismo permite criar tal estrutura, porém exigindo que cada tipo especializado tenha as suas próprias versões de implementação de seus métodos, que são diferentes dos métodos herdados. Junto com o polimorfismo, veremos com mais detalhes a sobreposição de métodos, que permite redefinir o comportamento (implementação) de um método que foi herdado, possibilitando que a subclasse possua os dois comportamentos: o herdado e o implementado.
      

    </td>
  </tr>

</tbody>
</table>
    
</section>

</main> 




</body>
</html>
